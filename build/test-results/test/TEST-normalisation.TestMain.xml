<?xml version="1.0" encoding="UTF-8"?>
<testsuite name="normalisation.TestMain" tests="9" skipped="0" failures="0" errors="0" timestamp="2020-03-21T16:08:55" hostname="pc5-013-l" time="1.294">
  <properties/>
  <testcase name="testRenamedMethods" classname="normalisation.TestMain" time="0.175"/>
  <testcase name="testReorderMethods" classname="normalisation.TestMain" time="0.08"/>
  <testcase name="testStringAlgorithm" classname="normalisation.TestMain" time="0.07"/>
  <testcase name="testNoComments" classname="normalisation.TestMain" time="0.014"/>
  <testcase name="testRenamedVariables" classname="normalisation.TestMain" time="0.032"/>
  <testcase name="testReorderImports" classname="normalisation.TestMain" time="0.018"/>
  <testcase name="testReduceStructures" classname="normalisation.TestMain" time="0.505"/>
  <testcase name="testAllChanged" classname="normalisation.TestMain" time="0.379"/>
  <testcase name="testReorderGlobalVariables" classname="normalisation.TestMain" time="0.016"/>
  <system-out><![CDATA[T size 363
P size 305
Coverage 390
127
import java.util.* ;
import java.util.concurrent.atomic.AtomicInteger ;
import java.util.function.Consumer ;
package normalisation ;
/**/n* This is a test class which acts as a base file for all the normalisation features to be tested on/n*/public class TestClass {
/* hello *//n/*/n*/
static final Integer foo = 0 ;
final String pop = "blah blah" ;
boolean dolphin ;
public static void main ( String[] args ) {
cat ( "hbjjhbhjb",5 ) ;
dog ( null ) ;
}
/**/n* Cat procedure abcd abcd/n* @param hat/n* @param j/n*/static public void cat ( String hat, Integer j ) {
System.out.println ( hat+ " " + j ) ;
for ( char c : hat.toCharArray ( ) ) {
System.out.println ( c ) ;
}
}
/**/n* Dog function blah blah/n* @param l/n* @return/n*/static boolean dog ( Map<String,Integer> l ) {
final Integer sum = new Integer ( ) ;
l.keySet ( ) .forEach ( new Consumer<String> ( ) {
@Override
public void accept ( String x ) {
sum.addAndGet ( l.get ( x ) ) ;
}
} ) ;
l.keySet ( ) .forEach ( x -> sum.addAndGet ( l.get ( x ) ) ) ;
l.keySet ( ) .forEach ( x -> {
sum.addAndGet ( l.get ( x ) ) ;
} ) ;
l.keySet ( ) .stream ( ) .map ( x -> {
return sum.addAndGet ( l.get ( x ) ) ;
} ) ;
return false ;
}
/**/n* Elephant method zzzz zzzz/n* @return/n*/private List<Decimal> elephant ( ) {
List<Decimal> o = new List<> ( ) ;
o.add ( 5d ) ;
o.add ( -1000d ) ;
o.remove ( ) ;
for ( Decimal aDouble : o ) {
System.out.println ( aDouble ) ;
}
return new List<> ( o ) ;
}
/**/n* Method to ensure bracket matching is resistant to strings containing brackets/n*/protected void brackets ( ) {
String brackets = " { { ( ) } { { { " ;
}
// bcdkscd cdsjcd cdscdc -void t ( ) {
}
public Map<Integer,Decimal> Integerer ( ) {
Map<Integer,Decimal> map = new Map<> ( ) ;
Decimal a ;
List h ;
List<String> l ;
return null ;
}
}




import java.util.* ;
import java.util.concurrent.atomic.AtomicInteger ;
import java.util.function.Consumer ;
package normalisation ;
/**/n* This is a test class which acts as a base file for all the normalisation features to be tested on/n*/public class TestClass {
/* hello *//n/*/n*/
static final Integer foo = 0 ;
final String pop = "blah blah" ;
boolean dolphin ;
public static void main ( String[] args ) {
cat ( "hbjjhbhjb",5 ) ;
dog ( null ) ;
}
/**/n* Cat procedure abcd abcd/n* @param hat/n* @param j/n*/static public void cat ( String hat, Integer j ) {
System.out.println ( hat+ " " + j ) ;
for ( char c : hat.toCharArray ( ) ) {
System.out.println ( c ) ;
}
}
/**/n* Dog function blah blah/n* @param l/n* @return/n*/static boolean dog ( Map<String,Integer> l ) {
final Integer sum = new Integer ( ) ;
l.keySet ( ) .forEach ( new Consumer<String> ( ) {
@Override
public void accept ( String x ) {
sum.addAndGet ( l.get ( x ) ) ;
}
} ) ;
l.keySet ( ) .forEach ( x -> sum.addAndGet ( l.get ( x ) ) ) ;
l.keySet ( ) .forEach ( x -> {
sum.addAndGet ( l.get ( x ) ) ;
} ) ;
l.keySet ( ) .stream ( ) .map ( x -> {
return sum.addAndGet ( l.get ( x ) ) ;
} ) ;
return false ;
}
/**/n* Elephant method zzzz zzzz/n* @return/n*/private List<Decimal> elephant ( ) {
List<Decimal> o = new List<> ( ) ;
o.add ( 5d ) ;
o.add ( -1000d ) ;
o.remove ( ) ;
for ( Decimal aDouble : o ) {
System.out.println ( aDouble ) ;
}
return new List<> ( o ) ;
}
/**/n* Method to ensure bracket matching is resistant to strings containing brackets/n*/protected void brackets ( ) {
String brackets = " { { ( ) } { { { " ;
}
// bcdkscd cdsjcd cdscdc -void t ( ) {
}
public Map<Integer,Decimal> Integerer ( ) {
Map<Integer,Decimal> map = new Map<> ( ) ;
Decimal a ;
List h ;
List<String> l ;
return null ;
}
}

]]></system-out>
  <system-err><![CDATA[]]></system-err>
</testsuite>
